The Ways of Dragging Dependent Tasks
===========================

There are several ways of implementing tasks moving with their dependent tasks:

Using Auto Scheduling Extension
------------------------

Firstly, you can make use of the desktop/auto_scheduling.md extension.
It allows scheduling tasks automatically depending on relations between them.

To use the auto scheduling functionality, you should include the **dhtmlxgantt_auto_scheduling.js** extension on the page:

~~~html
<script src="../codebase/ext/dhtmlxgantt_auto_scheduling.js"></script>
~~~

And set the **auto_scheduling** property to true:

~~~js
gantt.config.auto_scheduling = true;
~~~

Moving Tasks Manually
-----------------------

The common approach with dragging dependent tasks is the following:

- you detect when the task is being moved
- you traverse all dependent tasks and move them to the same (or different, depending on what you need) amount.

So, you can choose one of the two ways:

- [moving Descendants synchronously with the main task](#sync)
- [moving Descendants after movement of the main task is finished](#after)

In both cases, you need to get all linked tasks first.


<h3 id="linked_tasks">Getting all linked tasks</h3>

To retrieve the task related links, use the **$source** and **$target** properties of the task's object.
The properties are autogenerated and store ids of the related links:

- $source - the link that comes out from the task;
- $target - the link that comes into task.

~~~js
var taskObj = gantt.getTask("t1");
 
var sourceLinks = taskObj.$source;        //-> ["l1","l4"] - ids of coming-out links  
var targetLinks = taskObj.$target;       //-> ["l5","l8"] - ids of coming-into links
~~~

and from the links you can get the dependent tasks.

So, to get the linked tasks, we need to declare an iterator:

~~~js
gantt.eachSuccessor = function(callback, root){
  if(!this.isTaskExists(root))
    return;
  
  // remember tasks we've already iterated in order to avoid infinite loops
  var traversedTasks = arguments[2] || {};
  if(traversedTasks[root])
    return;
  traversedTasks[root] = true;
  
  var rootTask = this.getTask(root);
  var links = rootTask.$source;
  if(links){
    for(var i=0; i < links.length; i++){
      var link = this.getLink(links[i]);
      if(this.isTaskExists(link.target)){
        callback.call(this, this.getTask(link.target));
        
        // iterate the whole branch, not only first-level dependencies
        this.eachSuccessor(callback, link.target, traversedTasks);
      }
    }
  }
};
~~~


<h3 id="sync">Moving Descendants synchronously with the main task</h3>


Descendant tasks can be moved synchronously with the moving of the main tasks, i.e. when the user starts moving tasks, all dependent branches will be moved together. 
It will look good, but the downside is that there may be a performance drop, if you are moving many tasks at the same time.

1) First, you'll need to get all linked tasks, as it is described [above](#linked_tasks).


2) Then, the handler of the api/gantt_ontaskdrag_event.md event is applied:

~~~js
gantt.attachEvent("onTaskDrag", function(id, mode, task, original){
  var modes = gantt.config.drag_mode;
  if(mode == modes.move){
    var diff = task.start_date - original.start_date;
    gantt.eachSuccessor(function(child){
      child.start_date = new Date(+child.start_date + diff);
      child.end_date = new Date(+child.end_date + diff);
      gantt.refreshTask(child.id, true);
    },id );
  }
  return true;
});
~~~

3) Finally, to round positions of the child items to scale, the api/gantt_onaftertaskdrag_event.md event should be used:

~~~js
gantt.attachEvent("onAfterTaskDrag", function(id, mode, e){
  var modes = gantt.config.drag_mode;
  if(mode == modes.move ){
    gantt.eachSuccessor(function(child){
      child.start_date = gantt.roundDate(child.start_date);
      child.end_date = gantt.calculateEndDate(child.start_date, child.duration);
      gantt.updateTask(child.id);
    },id );
  }
});
~~~

This approach works fine if you don't have too many linked tasks.


<h3 id="after">Moving Descendants after movement of the main task is finished</h3>

Descendant tasks can be updated after the user finishes moving the main task. The result will look simpler, but have a better performance.

1) Firstly, we will declare the iterator, as it's shown [above](#linked_tasks).

2) Then, we define a "diff" variable that will keep the state of tasks shifting and set its initial value to 0. 
This variable should be cleared each time before task dragging:

~~~js
var diff = 0;
~~~

3) Each time when a task is dragged, the value of the "diff" variable will be recalculated as a difference between the initial start date and 
the new start date (after dragging). All the manipulations will be handled inside of the api/gantt_onbeforetaskchanged_event.md event handler.

We won't modify dependent tasks here, since api/gantt_onbeforetaskchanged_event.md is a blockable event. So, drag-n-drop of the primary task can still be canceled.

~~~js
gantt.attachEvent("onBeforeTaskChanged", function(id, mode, originalTask){
  var modes = gantt.config.drag_mode;
  if(mode == modes.move ){
  	var modifiedTask = gantt.getTask(id);
    diff = modifiedTask.start_date - originalTask.start_date;
  }
  return true;
});
~~~

4) As the last step, we'll apply the "diff" variable to all dependent tasks. 
It will be done from the onAfterTaskDrag handler which indicates that drag-n-drop of the primary task has been finished.

~~~js
//rounds positions of the child items to scale
  gantt.attachEvent("onAfterTaskDrag", function(id, mode, e){
    var modes = gantt.config.drag_mode;
    if(mode == modes.move ){
      gantt.eachSuccessor(function(child){
        child.start_date = gantt.roundDate(new Date(child.start_date.valueOf() + diff));
        child.end_date = gantt.calculateEndDate(child.start_date, child.duration);
        gantt.updateTask(child.id);
      },id );
    }
  });
~~~

In order to pass the "diff" value from the onBeforeTaskChanged to the onAfterTaskDrag event handler, 
we'll define both handlers and the "diff" variable in the same closure:

~~~js
(function(){
  
  var diff = 0;
  
  gantt.attachEvent("onBeforeTaskChanged", function(id, mode, originalTask){
    var modes = gantt.config.drag_mode;
    if(mode == modes.move ){
      var modifiedTask = gantt.getTask(id);
      diff = modifiedTask.start_date - originalTask.start_date;
    }
    return true;
  });
  
  //rounds positions of the child items to scale
  gantt.attachEvent("onAfterTaskDrag", function(id, mode, e){
    var modes = gantt.config.drag_mode;
    if(mode == modes.move ){
      gantt.eachSuccessor(function(child){
        child.start_date = gantt.roundDate(new Date(child.start_date.valueOf() + diff));
        child.end_date = gantt.calculateEndDate(child.start_date, child.duration);
        gantt.updateTask(child.id);
      },id );
    }
  });
})();
~~~